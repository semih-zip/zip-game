<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Zip Numbers â€” Drag Connect</title>
  <style>
    :root { font-family: -apple-system, BlinkMacSystemFont, "Noto Sans KR", system-ui, sans-serif; }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { margin:0; background:#0b0f14; color:#e8eef6; }
    .wrap { padding: 14px; padding-bottom: 22px; max-width: 980px; margin: 0 auto; }
    h1 { font-size: 16px; margin: 0 0 10px; font-weight: 800; letter-spacing: .2px; }

    .bar { display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between; }
    .row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .pill {
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 8px 10px;
      font-size: 13px;
      font-weight: 700;
    }

    button, select {
      background:#162031; color:#e8eef6;
      border:1px solid rgba(255,255,255,.16);
      padding: 12px 14px;
      border-radius: 14px;
      font-weight: 800;
      font-size: 14px;
      cursor: pointer;
      touch-action: manipulation;
    }
    button:disabled { opacity:.45; cursor:not-allowed; }

    .card {
      margin-top: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }

    #arena {
      margin-top: 10px;
      height: min(64vh, 560px);
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      position: relative;
      overflow:hidden;
      background:
        radial-gradient(900px 500px at 20% 10%, rgba(102, 226, 255, .14), transparent 60%),
        radial-gradient(900px 500px at 80% 90%, rgba(255, 140, 235, .12), transparent 60%),
        #0d131c;
      touch-action: none; /* critical: we handle drag ourselves */
    }

    canvas {
      position:absolute; inset:0;
      width:100%; height:100%;
      pointer-events:none;
    }

    .dot {
      position:absolute;
      width: 64px; height: 64px;
      border-radius: 22px;
      transform: translate(-50%, -50%);
      display:flex; align-items:center; justify-content:center;
      user-select:none;
      font-weight: 900;
      font-size: 18px;
      background: linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,.08));
      border:1px solid rgba(255,255,255,.22);
      box-shadow: 0 12px 26px rgba(0,0,0,.35);
      touch-action: none;
    }
    .dot.next {
      outline: 3px solid rgba(102,226,255,.55);
      outline-offset: 2px;
    }
    .dot.done { opacity: .72; }

    .hint { margin: 10px 2px 0; font-size: 12.5px; line-height: 1.45; opacity: .82; }

    .split { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px){ .split { grid-template-columns: 1.2fr .8fr; } }

    .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      white-space: pre-wrap;
      opacity: .92;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="bar">
      <h1>Zip Numbers â€” ë“œë˜ê·¸ë¡œ ìˆœì„œ ì—°ê²°</h1>
      <div class="row">
        <span class="pill">ìƒíƒœ: <strong id="status">ëŒ€ê¸°</strong></span>
        <span class="pill">ì§„í–‰: <strong id="progress">0/0</strong></span>
        <span class="pill">í˜„ì¬ ê¸°ë¡: <strong id="time">â€”</strong></span>
        <span class="pill">ìµœê³  ê¸°ë¡: <strong id="best">â€”</strong></span>
      </div>
    </div>

    <div class="split">
      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <div class="row">
            <label class="pill" style="display:flex;gap:8px;align-items:center;">
              ì  ê°œìˆ˜
              <select id="count">
                <option value="8">8 (Easy)</option>
                <option value="12" selected>12 (Normal)</option>
                <option value="16">16 (Hard)</option>
                <option value="20">20 (Very Hard)</option>
              </select>
            </label>
          </div>
          <div class="row">
            <button id="startBtn">ì‹œì‘</button>
            <button id="shuffleBtn">ìƒˆë¡œ ë°°ì¹˜</button>
          </div>
        </div>

        <div id="arena">
          <canvas id="lines"></canvas>
        </div>

        <div class="hint">
          <strong>1ì„ ëˆ„ë¥¸ ë’¤ ì†ê°€ë½ì„ ë–¼ì§€ ë§ê³ </strong> 2â†’3â†’â€¦ ìˆœì„œëŒ€ë¡œ ì§€ë‚˜ê°€ë©´ ì„ ì´ ì´ì–´ì ¸.
          ì¤‘ê°„ì— ì†ì„ ë–¼ë©´ ì‹¤íŒ¨(ë¦¬ì…‹) ì²˜ë¦¬.
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <strong>ê¸°ë¡</strong>
          <button id="clearBtn" style="padding:10px 12px;">ê¸°ë¡ ì´ˆê¸°í™”</button>
        </div>
        <div style="height:10px"></div>
        <div class="log" id="log"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const arena = document.getElementById('arena');
  const canvas = document.getElementById('lines');
  const ctx = canvas.getContext('2d');

  const statusEl = document.getElementById('status');
  const progressEl = document.getElementById('progress');
  const timeEl = document.getElementById('time');
  const bestEl = document.getElementById('best');
  const logEl = document.getElementById('log');

  const startBtn = document.getElementById('startBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const clearBtn = document.getElementById('clearBtn');
  const countSel = document.getElementById('count');

  const LS_BEST = 'zip_numbers_best_ms_v1';
  const LS_RUNS = 'zip_numbers_runs_v1'; // array of ms numbers

  let dots = []; // {n, x, y, el}
  let N = Number(countSel.value);

  let running = false;
  let dragging = false;
  let nextNeeded = 1;
  let path = []; // array of {x,y} for connected dots in order
  let startMs = 0;
  let raf = 0;

  function msToText(ms){
    const s = ms / 1000;
    if (s < 60) return `${s.toFixed(2)}s`;
    const m = Math.floor(s/60);
    const r = (s - m*60).toFixed(2).padStart(5,'0');
    return `${m}:${r}`;
  }

  function readBest(){
    const v = Number(localStorage.getItem(LS_BEST) || 0);
    bestEl.textContent = v ? msToText(v) : 'â€”';
  }

  function readRuns(){
    const raw = localStorage.getItem(LS_RUNS);
    let arr = [];
    try { if (raw) arr = JSON.parse(raw); } catch {}
    return Array.isArray(arr) ? arr : [];
  }

  function writeRuns(arr){
    localStorage.setItem(LS_RUNS, JSON.stringify(arr.slice(0, 15)));
  }

  function log(msg){
    const ts = new Date().toLocaleTimeString();
    logEl.textContent = `[${ts}] ${msg}\n` + logEl.textContent;
  }

  function setStatus(s){ statusEl.textContent = s; }

  function resizeCanvas(){
    const r = arena.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    canvas.style.width = r.width + 'px';
    canvas.style.height = r.height + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  function clearDots(){
    dots.forEach(d => d.el.remove());
    dots = [];
  }

  function placeDots(){
    clearDots();
    N = Number(countSel.value);

    const r = arena.getBoundingClientRect();
    const pad = 48;          // safe padding
    const minDist = 62;      // reduce overlaps

    function tooClose(x,y, arr){
      for (const p of arr){
        const dx = x - p.x, dy = y - p.y;
        if (Math.hypot(dx,dy) < minDist) return true;
      }
      return false;
    }

    const pts = [];
    let guard = 0;
    while (pts.length < N && guard++ < 4000){
      const x = pad + Math.random() * (r.width - pad*2);
      const y = pad + Math.random() * (r.height - pad*2);
      if (!tooClose(x,y, pts)) pts.push({x,y});
    }

    for (let i=1;i<=N;i++){
      const p = pts[i-1];
      const el = document.createElement('div');
      el.className = 'dot';
      el.textContent = String(i);
      el.style.left = `${p.x}px`;
      el.style.top = `${p.y}px`;
      // we intentionally DO NOT use click; drag hit-testing uses geometry
      arena.appendChild(el);
      dots.push({ n:i, x:p.x, y:p.y, el });
    }

    progressEl.textContent = `0/${N}`;
    highlightNext();
    draw();
  }

  function highlightNext(){
    dots.forEach(d => d.el.classList.remove('next'));
    const d = dots.find(x => x.n === nextNeeded);
    if (d) d.el.classList.add('next');
  }

  function resetRun(reason){
    running = false;
    dragging = false;
    nextNeeded = 1;
    path = [];
    cancelAnimationFrame(raf);
    raf = 0;
    timeEl.textContent = 'â€”';
    setStatus('ëŒ€ê¸°');
    dots.forEach(d => d.el.classList.remove('done'));
    highlightNext();
    draw();
    if (reason) log(`ë¦¬ì…‹: ${reason}`);
  }

  function startRun(){
    resetRun();
    running = true;
    setStatus('ì¤€ë¹„: 1ì—ì„œ ì‹œì‘');
    progressEl.textContent = `0/${N}`;
    highlightNext();
    draw();
  }

  function finishRun(){
    running = false;
    dragging = false;
    cancelAnimationFrame(raf);
    raf = 0;

    const elapsed = performance.now() - startMs;
    timeEl.textContent = msToText(elapsed);
    setStatus('ì™„ë£Œ');

    // best
    const best = Number(localStorage.getItem(LS_BEST) || 0);
    if (!best || elapsed < best){
      localStorage.setItem(LS_BEST, String(Math.round(elapsed)));
      readBest();
      log(`ğŸ ì‹ ê¸°ë¡! ${msToText(elapsed)}`);
    } else {
      log(`ì™„ë£Œ: ${msToText(elapsed)}`);
    }

    // runs
    const runs = readRuns();
    runs.unshift(Math.round(elapsed));
    writeRuns(runs);
    renderRuns();
  }

  function renderRuns(){
    const runs = readRuns();
    if (!runs.length){
      logEl.textContent = 'ê¸°ë¡ì´ ì•„ì§ ì—†ì–´.\n(ì™„ì£¼í•˜ë©´ ì—¬ê¸°ì— ì €ì¥ë¼)\n' + logEl.textContent;
      return;
    }
    const lines = runs.slice(0,10).map((ms, i) => `${String(i+1).padStart(2,'0')}. ${msToText(ms)}`).join('\n');
    const header = `ìµœê·¼ ê¸°ë¡ TOP ${Math.min(10, runs.length)}\n${lines}\n\n`;
    // keep newest log messages under header
    const rest = logEl.textContent.split('\n').slice(0,60).join('\n');
    logEl.textContent = header + rest;
  }

  function draw(pointer=null){
    // pointer: {x,y} in arena coords while dragging
    const w = arena.clientWidth;
    const h = arena.clientHeight;
    ctx.clearRect(0,0,w,h);

    // base style
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    // draw connected path
    if (path.length >= 2){
      ctx.lineWidth = 8;
      ctx.strokeStyle = 'rgba(102,226,255,.70)';
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for (let i=1;i<path.length;i++) ctx.lineTo(path[i].x, path[i].y);
      ctx.stroke();
    }

    // draw active line to pointer while dragging
    if (dragging && path.length >= 1 && pointer){
      const last = path[path.length-1];
      ctx.lineWidth = 6;
      ctx.strokeStyle = 'rgba(255,255,255,.35)';
      ctx.beginPath();
      ctx.moveTo(last.x, last.y);
      ctx.lineTo(pointer.x, pointer.y);
      ctx.stroke();
    }
  }

  function arenaPointFromEvent(e){
    const r = arena.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  // Hit-test: returns dot number if pointer is within radius
  function hitDot(pt){
    const radius = 42; // forgiving for fingers
    for (const d of dots){
      const dx = pt.x - d.x, dy = pt.y - d.y;
      if (Math.hypot(dx,dy) <= radius) return d.n;
    }
    return null;
  }

  function markDone(n){
    const d = dots.find(x => x.n === n);
    if (d) d.el.classList.add('done');
  }

  function tickTimer(){
    if (!running || !dragging) return;
    const elapsed = performance.now() - startMs;
    timeEl.textContent = msToText(elapsed);
    raf = requestAnimationFrame(tickTimer);
  }

  // Pointer handling
  let pointerId = null;

  arena.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    if (!running) return;

    // lock to first pointer only
    if (pointerId !== null) return;
    pointerId = e.pointerId;
    arena.setPointerCapture(pointerId);

    const pt = arenaPointFromEvent(e);
    const hit = hitDot(pt);

    // Must start on 1
    if (nextNeeded === 1){
      if (hit !== 1){
        // ignore (donâ€™t fail) â€” just require starting at 1
        setStatus('1ì—ì„œ ì‹œì‘');
        draw(pt);
        return;
      }
      // start drag officially
      dragging = true;
      startMs = performance.now();
      setStatus('ì§„í–‰ì¤‘');
      path = [{ x: dots[0].x, y: dots[0].y }];
      markDone(1);
      nextNeeded = 2;
      progressEl.textContent = `1/${N}`;
      highlightNext();
      draw(pt);
      cancelAnimationFrame(raf);
      raf = requestAnimationFrame(tickTimer);
      return;
    }

    // If already started but pointerdown again (shouldnâ€™t normally), treat as fail
    if (nextNeeded > 1){
      resetRun('ì¤‘ê°„ì— ë‹¤ì‹œ ëˆŒë €ì–´ (ì† ë–¼ë©´ ì‹¤íŒ¨)');
    }
  }, { passive:false });

  arena.addEventListener('pointermove', (e) => {
    if (!running) return;
    if (pointerId === null || e.pointerId !== pointerId) return;

    const pt = arenaPointFromEvent(e);

    if (!dragging){
      // not started yet, just show guide line from nothing
      draw(pt);
      return;
    }

    // must stay dragging; check if you reached next dot
    const hit = hitDot(pt);
    if (hit === nextNeeded){
      const d = dots.find(x => x.n === hit);
      path.push({ x:d.x, y:d.y });
      markDone(hit);
      progressEl.textContent = `${hit}/${N}`;

      if (hit === N){
        // finished without lifting
        draw(pt);
        finishRun();
        pointerId = null;
        try { arena.releasePointerCapture(e.pointerId); } catch {}
        return;
      }

      nextNeeded += 1;
      highlightNext();
    }

    draw(pt);
  }, { passive:false });

  function failIfDragging(reason){
    if (dragging){
      resetRun(reason);
    } else {
      setStatus('ëŒ€ê¸°');
    }
    pointerId = null;
  }

  arena.addEventListener('pointerup', (e) => {
    if (pointerId === null || e.pointerId !== pointerId) return;
    e.preventDefault();
    // If you lift before finishing => fail
    if (running && dragging) failIfDragging('ì†ì„ ë–¼ì„œ ì‹¤íŒ¨');
    else pointerId = null;
    try { arena.releasePointerCapture(e.pointerId); } catch {}
  }, { passive:false });

  arena.addEventListener('pointercancel', (e) => {
    if (pointerId === null || e.pointerId !== pointerId) return;
    e.preventDefault();
    if (running && dragging) failIfDragging('ì…ë ¥ì´ ì·¨ì†Œë¼ì„œ ì‹¤íŒ¨');
    else pointerId = null;
  }, { passive:false });

  // Buttons
  startBtn.addEventListener('click', () => {
    startRun();
    log('ì‹œì‘ ëˆŒë¦¼: 1ì„ ë“œë˜ê·¸ë¡œ ì‹œì‘í•´ì¤˜');
  });

  shuffleBtn.addEventListener('click', () => {
    resetRun();
    placeDots();
    log('ìƒˆë¡œ ë°°ì¹˜');
  });

  clearBtn.addEventListener('click', () => {
    localStorage.removeItem(LS_BEST);
    localStorage.removeItem(LS_RUNS);
    readBest();
    logEl.textContent = '';
    log('ê¸°ë¡ ì´ˆê¸°í™”');
  });

  countSel.addEventListener('change', () => {
    resetRun();
    placeDots();
    log(`ì  ê°œìˆ˜ ë³€ê²½: ${countSel.value}`);
  });

  window.addEventListener('resize', () => {
    resizeCanvas();
  });

  // init
  readBest();
  placeDots();
  resizeCanvas();
  renderRuns();
  log('ì¤€ë¹„ ì™„ë£Œ. ì‹œì‘ì„ ëˆ„ë¥´ê³  1ì—ì„œ ì†ì„ ë–¼ì§€ ë§ê³  ëê¹Œì§€ ì´ì–´ì¤˜.');
})();
</script>
</body>
</html>
